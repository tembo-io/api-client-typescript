// This file is auto-generated by @hey-api/openapi-ts

export const ActionSchema = {
	type: "object",
	required: ["id", "name", "description"],
	properties: {
		description: {
			type: "string",
			example: "Allows creating a new instance within an organization.",
		},
		id: {
			type: "string",
			description: `A valid Action ID. Available Action IDs include 'CreateInstance' and 'ManagePermissions'.
Find all available Actions on the Actions API.`,
			example: "CreateInstance",
		},
		name: {
			type: "string",
			example: "Create Instance",
		},
	},
} as const;

export const AppConfigSchema = {
	type: "object",
	properties: {
		env: {
			type: "array",
			items: {
				$ref: "#/components/schemas/EnvVar",
			},
			nullable: true,
		},
		resources: {
			allOf: [
				{
					$ref: "#/components/schemas/ResourceRequirements",
				},
			],
			nullable: true,
		},
	},
} as const;

export const AppMetricsSchema = {
	type: "object",
	required: ["port", "path"],
	properties: {
		path: {
			type: "string",
			description: "path to scrape metrics",
		},
		port: {
			type: "integer",
			format: "int32",
			description: "port must be also exposed in one of AppService.routing[]",
			minimum: 0,
		},
	},
} as const;

export const AppServiceSchema = {
	type: "object",
	description: `AppService significantly extends the functionality of your Tembo Postgres
instance by running tools and software built by the Postgres open source community.

**Example**: This will configure and install a Postgrest container along side
the Postgres instance, install pg_graphql extension, and configure the
ingress routing to expose the Postgrest service.

\`\`\`yaml
apiVersion: coredb.io/v1alpha1
kind: CoreDB
metadata:
name: test-db
spec:
trunk_installs:
- name: pg_graphql
version: 1.2.0
extensions:
- name: pg_graphql
locations:
- database: postgres
enabled: true

appServices:
- name: postgrest
image: postgrest/postgrest:v10.0.0
routing:
# only expose /rest/v1 and /graphql/v1
- port: 3000
ingressPath: /rest/v1
middlewares:
- my-headers
- port: 3000
ingressPath: /graphql/v1
middlewares:
- map-gql
- my-headers
middlewares:
- customRequestHeaders:
name: my-headers
config:
# removes auth header from request
Authorization: ""
Content-Profile: graphql
Accept-Profile: graphql
- stripPrefix:
name: my-strip-prefix
config:
- /rest/v1
# reroute gql and rest requests
- replacePathRegex:
name: map-gql
config:
regex: \/graphql\/v1\/?
replacement: /rpc/resolve
env:
- name: PGRST_DB_URI
valueFromPlatform: ReadWriteConnection
- name: PGRST_DB_SCHEMA
value: "public, graphql"
- name: PGRST_DB_ANON_ROLE
value: postgres
- name: PGRST_LOG_LEVEL
value: info
\`\`\``,
	required: ["name", "image"],
	properties: {
		args: {
			type: "array",
			items: {
				type: "string",
			},
			description: `Defines the arguments to pass into the container if needed.
You define this in the same manner as you would for all Kubernetes containers.
See the [Kubernetes docs](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container).`,
			nullable: true,
		},
		command: {
			type: "array",
			items: {
				type: "string",
			},
			description: `Defines the command into the container if needed.
You define this in the same manner as you would for all Kubernetes containers.
See the [Kubernetes docs](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container).`,
			nullable: true,
		},
		env: {
			type: "array",
			items: {
				$ref: "#/components/schemas/EnvVar",
			},
			description: `Defines the environment variables to pass into the container if needed.
You define this in the same manner as you would for all Kubernetes containers.
See the [Kubernetes docs](https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container).`,
			nullable: true,
		},
		image: {
			type: "string",
			description: "Defines the container image to use for the appService.",
		},
		metrics: {
			allOf: [
				{
					$ref: "#/components/schemas/AppMetrics",
				},
			],
			nullable: true,
		},
		middlewares: {
			type: "array",
			items: {
				$ref: "#/components/schemas/Middleware",
			},
			description: `Defines the ingress middeware configuration for the appService.
This is specifically configured for the ingress controller Traefik.`,
			nullable: true,
		},
		name: {
			type: "string",
			description: "Defines the name of the appService.",
		},
		probes: {
			allOf: [
				{
					$ref: "#/components/schemas/Probes",
				},
			],
			nullable: true,
		},
		resources: {
			$ref: "#/components/schemas/ResourceRequirements",
		},
		routing: {
			type: "array",
			items: {
				$ref: "#/components/schemas/Routing",
			},
			description: "Defines the routing configuration for the appService.",
			nullable: true,
		},
		storage: {
			allOf: [
				{
					$ref: "#/components/schemas/StorageConfig",
				},
			],
			nullable: true,
		},
	},
} as const;

export const AppTypeSchema = {
	oneOf: [
		{
			type: "object",
			required: ["ai-proxy"],
			properties: {
				"ai-proxy": {
					allOf: [
						{
							$ref: "#/components/schemas/AppConfig",
						},
					],
					nullable: true,
				},
			},
		},
		{
			type: "object",
			required: ["restapi"],
			properties: {
				restapi: {
					allOf: [
						{
							$ref: "#/components/schemas/AppConfig",
						},
					],
					nullable: true,
				},
			},
		},
		{
			type: "object",
			required: ["http"],
			properties: {
				http: {
					allOf: [
						{
							$ref: "#/components/schemas/AppConfig",
						},
					],
					nullable: true,
				},
			},
		},
		{
			type: "object",
			required: ["mq-api"],
			properties: {
				"mq-api": {
					allOf: [
						{
							$ref: "#/components/schemas/AppConfig",
						},
					],
					nullable: true,
				},
			},
		},
		{
			type: "object",
			required: ["embeddings"],
			properties: {
				embeddings: {
					allOf: [
						{
							$ref: "#/components/schemas/AppConfig",
						},
					],
					nullable: true,
				},
			},
		},
		{
			type: "object",
			required: ["pganalyze"],
			properties: {
				pganalyze: {
					allOf: [
						{
							$ref: "#/components/schemas/AppConfig",
						},
					],
					nullable: true,
				},
			},
		},
		{
			type: "object",
			required: ["sqlrunner"],
			properties: {
				sqlrunner: {
					allOf: [
						{
							$ref: "#/components/schemas/AppConfig",
						},
					],
					nullable: true,
				},
			},
		},
		{
			type: "object",
			required: ["custom"],
			properties: {
				custom: {
					$ref: "#/components/schemas/AppService",
				},
			},
		},
	],
} as const;

export const AskParamsSchema = {
	type: "object",
	required: ["query"],
	properties: {
		query: {
			type: "string",
			description:
				'The ask query. For example, "how to create a Tembo instance"',
		},
	},
} as const;

export const AskResultSchema = {
	type: "object",
	required: ["chat_response"],
	properties: {
		chat_response: {
			type: "string",
			description:
				'The ask query. For example, "how to create a Tembo instance"',
		},
		context: {
			type: "array",
			items: {
				$ref: "#/components/schemas/SearchResponse",
			},
			description:
				"an array of json objects referencing documents used to generate the response",
			nullable: true,
		},
	},
} as const;

export const AutoStopSchema = {
	type: "object",
	description: `AutoStop configures automatic stopping of idle instances.
An instance is considered idle if it is more than two days old, hasn't been connected to in over a day, and has not been resumed within the last day.
Idle instances are stopped in the time window 9-9:30 AM ET.`,
	required: ["enabled"],
	properties: {
		enabled: {
			type: "boolean",
			description: "Enable automatic stopping of the instance when idle.",
		},
	},
} as const;

export const AutoscalingSchema = {
	type: "object",
	properties: {
		autostop: {
			$ref: "#/components/schemas/AutoStop",
		},
		storage: {
			$ref: "#/components/schemas/AutoscalingStorage",
		},
	},
} as const;

export const AutoscalingStorageSchema = {
	type: "object",
	description:
		"AutoscalingStorage configures the automatic scaling of instance storage.",
	required: ["enabled"],
	properties: {
		enabled: {
			type: "boolean",
			description: "Enable autoscaling for storage",
		},
		maximum: {
			allOf: [
				{
					$ref: "#/components/schemas/Storage",
				},
			],
			nullable: true,
		},
	},
} as const;

export const ConnectionInfoSchema = {
	type: "object",
	required: ["host", "port", "user"],
	properties: {
		host: {
			type: "string",
		},
		pooler_host: {
			type: "string",
			nullable: true,
		},
		port: {
			type: "integer",
			format: "int32",
		},
		user: {
			type: "string",
		},
	},
} as const;

export const ConnectionPoolerSchema = {
	type: "object",
	description: `A connection pooler is a tool used to manage database connections, sitting
between your application and Postgres instance. Because of the way Postgres
handles connections, the server may encounter resource constraint issues
when managing a few thousand connections. Using a pooler can alleviate these
issues by using actual Postgres connections only when necessary

**Example**: A typical connection pooler configuration

\`\`\`yaml
apiVersion: coredb.io/v1alpha1
kind: CoreDB
metadata:
name: test-db
spec:
connectionPooler:
enabled: true
pooler:
poolMode: transaction
# Valid parameter values can be found at https://www.pgbouncer.org/config.html
parameters:
default_pool_size: "50"
max_client_conn: "5000"
resources:
limits:
cpu: 200m
memory: 256Mi
requests:
cpu: 100m
memory: 128Mi
\`\`\``,
	properties: {
		enabled: {
			type: "boolean",
			description: `Enable the connection pooler

**Default**: false.`,
		},
		pooler: {
			$ref: "#/components/schemas/PgBouncer",
		},
	},
} as const;

export const CpuSchema = {
	type: "string",
	enum: ["0.25", "0.5", "1", "2", "4", "6", "8", "12", "16", "32"],
} as const;

export const CreateInstanceSchema = {
	type: "object",
	required: [
		"instance_name",
		"stack_type",
		"cpu",
		"memory",
		"storage",
		"environment",
	],
	properties: {
		app_services: {
			type: "array",
			items: {
				$ref: "#/components/schemas/AppType",
			},
			nullable: true,
		},
		autoscaling: {
			allOf: [
				{
					$ref: "#/components/schemas/PatchAutoscaling",
				},
			],
			nullable: true,
		},
		connection_pooler: {
			allOf: [
				{
					$ref: "#/components/schemas/ConnectionPooler",
				},
			],
			nullable: true,
		},
		cpu: {
			$ref: "#/components/schemas/Cpu",
		},
		dedicated_networking: {
			allOf: [
				{
					$ref: "#/components/schemas/dedicated_networking",
				},
			],
			nullable: true,
		},
		environment: {
			$ref: "#/components/schemas/Environment",
		},
		experimental: {
			allOf: [
				{
					$ref: "#/components/schemas/Experimental",
				},
			],
			nullable: true,
		},
		extensions: {
			type: "array",
			items: {
				$ref: "#/components/schemas/Extension",
			},
			nullable: true,
		},
		extra_domains_rw: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		instance_name: {
			type: "string",
		},
		ip_allow_list: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		memory: {
			$ref: "#/components/schemas/Memory",
		},
		pg_version: {
			type: "integer",
			format: "int32",
			minimum: 0,
		},
		postgres_configs: {
			type: "array",
			items: {
				$ref: "#/components/schemas/PgConfig",
			},
			nullable: true,
		},
		provider_id: {
			type: "string",
		},
		region_id: {
			type: "string",
		},
		replicas: {
			$ref: "#/components/schemas/Replicas",
		},
		spot: {
			type: "boolean",
			nullable: true,
		},
		stack_type: {
			$ref: "#/components/schemas/StackType",
		},
		storage: {
			$ref: "#/components/schemas/Storage",
		},
		trunk_installs: {
			type: "array",
			items: {
				$ref: "#/components/schemas/TrunkInstall",
			},
			nullable: true,
		},
	},
} as const;

export const DataPlaneSchema = {
	type: "object",
	required: [
		"provider_name",
		"provider_id",
		"region",
		"region_name",
		"region_id",
		"index",
	],
	properties: {
		index: {
			type: "string",
			example: "data-1",
		},
		provider_id: {
			type: "string",
			example: "aws",
		},
		provider_name: {
			type: "string",
			example: "AWS",
		},
		region: {
			type: "string",
			example: "us-east-1",
		},
		region_id: {
			type: "string",
			example: "use1",
		},
		region_name: {
			type: "string",
			example: "US East 1 (N. Virginia)",
		},
	},
} as const;

export const EnvVarSchema = {
	type: "object",
	required: ["name"],
	properties: {
		name: {
			type: "string",
		},
		value: {
			type: "string",
			nullable: true,
		},
		valueFromPlatform: {
			allOf: [
				{
					$ref: "#/components/schemas/EnvVarRef",
				},
			],
			nullable: true,
		},
	},
} as const;

export const EnvVarRefSchema = {
	type: "string",
	enum: ["ReadOnlyConnection", "ReadWriteConnection"],
} as const;

export const EnvironmentSchema = {
	type: "string",
	enum: ["dev", "test", "prod"],
} as const;

export const ErrorResponseSchemaSchema = {
	type: "object",
	required: ["error"],
	properties: {
		error: {
			type: "string",
		},
	},
} as const;

export const ExperimentalSchema = {
	type: "object",
	properties: {
		image: {
			type: "string",
			nullable: true,
		},
	},
} as const;

export const ExtensionSchema = {
	type: "object",
	description: `Extension lets you define a list of extensions to enable on the instance. To enable
extensions, you must specify the name of the extension and the database, schema, and
version to enable it on. If the version is not specified, the latest version will be
used.  The extension must also be installed on the instance.  To install
extensions, please refer to the \`TrunkInstall\` resource.

This example will enable the pg_stat_statements extension on the Postgres database
in the public schema.

\`\`\`yaml
apiVersion: coredb.io/v1alpha1
kind: CoreDB
metadata:
name: test-db
spec:
extensions:
- name: pg_stat_statements
locations:
- database: postgres
enabled: true
schema: public
version: 1.10.0
\`\`\`\``,
	required: ["name", "locations"],
	properties: {
		description: {
			type: "string",
			description: `A description of the extension. (Optional)

**Default**: "No description provided"`,
			nullable: true,
		},
		locations: {
			type: "array",
			items: {
				$ref: "#/components/schemas/ExtensionInstallLocation",
			},
			description:
				"A list of locations (databases) to enabled the extension on.",
		},
		name: {
			type: "string",
			description: "The name of the extension to enable.",
		},
	},
} as const;

export const ExtensionInstallLocationSchema = {
	type: "object",
	description: `ExtensionInstallLocation lets you specify the database, schema, and version to enable
an extension on.`,
	required: ["enabled"],
	properties: {
		database: {
			type: "string",
			description: `The database to enable the extension on.

**Default**: "postgres"`,
		},
		enabled: {
			type: "boolean",
			description: "Enable or disable the extension on this Postgres instance.",
		},
		schema: {
			type: "string",
			description: 'The schema to enable the extension on. (eg: "public")',
			nullable: true,
		},
		version: {
			type: "string",
			description:
				"The extension version to install. If not specified, the latest version will be used.",
			nullable: true,
		},
	},
} as const;

export const ExtensionInstallLocationStatusSchema = {
	type: "object",
	properties: {
		database: {
			type: "string",
		},
		enabled: {
			type: "boolean",
			nullable: true,
		},
		error: {
			type: "boolean",
			nullable: true,
		},
		error_message: {
			type: "string",
			nullable: true,
		},
		schema: {
			type: "string",
			nullable: true,
		},
		version: {
			type: "string",
			nullable: true,
		},
	},
} as const;

export const ExtensionStatusSchema = {
	type: "object",
	required: ["name", "locations"],
	properties: {
		description: {
			type: "string",
			nullable: true,
		},
		locations: {
			type: "array",
			items: {
				$ref: "#/components/schemas/ExtensionInstallLocationStatus",
			},
		},
		name: {
			type: "string",
		},
	},
} as const;

export const HeaderConfigSchema = {
	type: "object",
	required: ["name", "config"],
	properties: {
		config: {
			type: "object",
			additionalProperties: {
				type: "string",
			},
		},
		name: {
			type: "string",
		},
	},
} as const;

export const HistoryEntrySchema = {
	type: "object",
	required: ["timestamp", "instance"],
	properties: {
		instance: {
			$ref: "#/components/schemas/InstanceState",
		},
		timestamp: {
			type: "string",
			format: "date-time",
			description: "The timestamp of the entry",
		},
	},
} as const;

export const HistoryPageSchema = {
	type: "object",
	required: ["history", "pagination"],
	properties: {
		history: {
			type: "array",
			items: {
				$ref: "#/components/schemas/HistoryEntry",
			},
			description: "List of historical results",
		},
		pagination: {
			$ref: "#/components/schemas/PaginationInfo",
		},
	},
} as const;

export const InfrastructureSchema = {
	type: "object",
	properties: {
		cpu: {
			type: "string",
		},
		memory: {
			type: "string",
		},
		storage: {
			type: "string",
		},
	},
} as const;

export const IngressSchema = {
	type: "object",
	required: ["enabled"],
	properties: {
		enabled: {
			type: "boolean",
		},
		path: {
			type: "string",
			nullable: true,
		},
	},
} as const;

export const IngressTypeSchema = {
	type: "string",
	enum: ["http", "tcp"],
} as const;

export const InstanceSchema = {
	type: "object",
	required: [
		"instance_id",
		"instance_name",
		"stack_type",
		"organization_id",
		"organization_name",
		"namespace",
		"state",
		"cpu",
		"memory",
		"storage",
		"environment",
		"replicas",
		"postgres_version",
		"region_id",
		"provider_id",
		"dataplane_index",
		"region_name",
		"autoscaling",
	],
	properties: {
		app_services: {
			type: "array",
			items: {
				$ref: "#/components/schemas/AppType",
			},
			nullable: true,
		},
		autoscaling: {
			$ref: "#/components/schemas/Autoscaling",
		},
		connection_info: {
			allOf: [
				{
					$ref: "#/components/schemas/ConnectionInfo",
				},
			],
			nullable: true,
		},
		connection_pooler: {
			allOf: [
				{
					$ref: "#/components/schemas/ConnectionPooler",
				},
			],
			nullable: true,
		},
		cpu: {
			$ref: "#/components/schemas/Cpu",
		},
		created_at: {
			type: "string",
			format: "date-time",
		},
		dataplane_index: {
			type: "string",
		},
		dedicated_networking: {
			allOf: [
				{
					$ref: "#/components/schemas/dedicated_networking",
				},
			],
			nullable: true,
		},
		environment: {
			$ref: "#/components/schemas/Environment",
		},
		extensions: {
			type: "array",
			items: {
				$ref: "#/components/schemas/ExtensionStatus",
			},
			nullable: true,
		},
		extra_domains_rw: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		first_recoverability_time: {
			type: "string",
			format: "date-time",
			nullable: true,
		},
		image: {
			type: "string",
			nullable: true,
		},
		instance_id: {
			type: "string",
		},
		instance_name: {
			type: "string",
		},
		ip_allow_list: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		last_updated_at: {
			type: "string",
			format: "date-time",
		},
		last_wal_archive_status: {
			type: "string",
			format: "date-time",
			nullable: true,
		},
		memory: {
			$ref: "#/components/schemas/Memory",
		},
		namespace: {
			type: "string",
		},
		organization_id: {
			type: "string",
		},
		organization_name: {
			type: "string",
			deprecated: true,
		},
		postgres_configs: {
			type: "array",
			items: {
				$ref: "#/components/schemas/PgConfig",
			},
			nullable: true,
		},
		postgres_version: {
			type: "integer",
			format: "int32",
			description: `Major Postgres version this instance is using.
Currently: 14, 15 or 16`,
			minimum: 0,
		},
		provider_id: {
			type: "string",
		},
		region_id: {
			type: "string",
		},
		region_name: {
			type: "string",
		},
		replicas: {
			$ref: "#/components/schemas/Replicas",
		},
		runtime_config: {
			type: "array",
			items: {
				$ref: "#/components/schemas/PgConfig",
			},
			nullable: true,
		},
		spot: {
			type: "boolean",
			nullable: true,
		},
		stack_type: {
			$ref: "#/components/schemas/StackType",
		},
		state: {
			$ref: "#/components/schemas/State",
		},
		storage: {
			$ref: "#/components/schemas/Storage",
		},
		trunk_installs: {
			type: "array",
			items: {
				$ref: "#/components/schemas/TrunkInstallStatus",
			},
			nullable: true,
		},
	},
} as const;

export const InstanceEventSchema = {
	type: "string",
	enum: ["restart", "stop", "start"],
} as const;

export const InstanceStateSchema = {
	type: "object",
	required: ["state"],
	properties: {
		state: {
			$ref: "#/components/schemas/State",
		},
	},
} as const;

export const IntOrStringSchema = {
	oneOf: [
		{
			type: "object",
			required: ["Int"],
			properties: {
				Int: {
					type: "integer",
					format: "int32",
				},
			},
		},
		{
			type: "object",
			required: ["String"],
			properties: {
				String: {
					type: "string",
				},
			},
		},
	],
} as const;

export const MemorySchema = {
	type: "string",
	enum: ["1Gi", "2Gi", "4Gi", "8Gi", "12Gi", "16Gi", "24Gi", "32Gi", "64Gi"],
} as const;

export const MiddlewareSchema = {
	oneOf: [
		{
			type: "object",
			required: ["customRequestHeaders"],
			properties: {
				customRequestHeaders: {
					$ref: "#/components/schemas/HeaderConfig",
				},
			},
		},
		{
			type: "object",
			required: ["stripPrefix"],
			properties: {
				stripPrefix: {
					$ref: "#/components/schemas/StripPrefixConfig",
				},
			},
		},
		{
			type: "object",
			required: ["replacePathRegex"],
			properties: {
				replacePathRegex: {
					$ref: "#/components/schemas/ReplacePathRegexConfig",
				},
			},
		},
	],
	description: `Midddleware is used to configure the middleware for the appService.
This is specifically configured for the ingress controller Traefik.

Please refer to the example in the \`AppService\` documentation.`,
} as const;

export const PaginationInfoSchema = {
	type: "object",
	required: ["currentPage", "limit", "hasMore"],
	properties: {
		currentPage: {
			type: "integer",
			format: "int32",
			description: "The page returned",
			minimum: 0,
		},
		hasMore: {
			type: "boolean",
			description: "True if more results are available on the next page",
		},
		limit: {
			type: "integer",
			format: "int32",
			description: "The maximum number of results returned",
			minimum: 0,
		},
	},
} as const;

export const PatchAutoscalingSchema = {
	type: "object",
	properties: {
		autostop: {
			allOf: [
				{
					$ref: "#/components/schemas/AutoStop",
				},
			],
			nullable: true,
		},
		storage: {
			allOf: [
				{
					$ref: "#/components/schemas/AutoscalingStorage",
				},
			],
			nullable: true,
		},
	},
} as const;

export const PatchInstanceSchema = {
	type: "object",
	properties: {
		app_services: {
			type: "array",
			items: {
				$ref: "#/components/schemas/AppType",
			},
			nullable: true,
		},
		autoscaling: {
			allOf: [
				{
					$ref: "#/components/schemas/PatchAutoscaling",
				},
			],
			nullable: true,
		},
		connection_pooler: {
			allOf: [
				{
					$ref: "#/components/schemas/ConnectionPooler",
				},
			],
			nullable: true,
		},
		cpu: {
			allOf: [
				{
					$ref: "#/components/schemas/Cpu",
				},
			],
			nullable: true,
		},
		dedicated_networking: {
			allOf: [
				{
					$ref: "#/components/schemas/dedicated_networking",
				},
			],
			nullable: true,
		},
		environment: {
			allOf: [
				{
					$ref: "#/components/schemas/Environment",
				},
			],
			nullable: true,
		},
		experimental: {
			allOf: [
				{
					$ref: "#/components/schemas/Experimental",
				},
			],
			nullable: true,
		},
		extensions: {
			type: "array",
			items: {
				$ref: "#/components/schemas/Extension",
			},
			nullable: true,
		},
		extra_domains_rw: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		instance_name: {
			type: "string",
			nullable: true,
		},
		ip_allow_list: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		memory: {
			allOf: [
				{
					$ref: "#/components/schemas/Memory",
				},
			],
			nullable: true,
		},
		postgres_configs: {
			type: "array",
			items: {
				$ref: "#/components/schemas/PgConfig",
			},
			nullable: true,
		},
		replicas: {
			allOf: [
				{
					$ref: "#/components/schemas/Replicas",
				},
			],
			nullable: true,
		},
		spot: {
			type: "boolean",
			nullable: true,
		},
		storage: {
			allOf: [
				{
					$ref: "#/components/schemas/Storage",
				},
			],
			nullable: true,
		},
		trunk_installs: {
			type: "array",
			items: {
				$ref: "#/components/schemas/TrunkInstall",
			},
			nullable: true,
		},
	},
} as const;

export const PgBouncerSchema = {
	type: "object",
	description: "PgBouncer is the type for the PGBouncer configuration",
	properties: {
		parameters: {
			type: "object",
			description:
				"Valid pgbouncer parameter values can be found at [https://www.pgbouncer.org/config.html](https://www.pgbouncer.org/config.html)",
			additionalProperties: {
				type: "string",
			},
			nullable: true,
		},
		poolMode: {
			$ref: "#/components/schemas/PoolerPgbouncerPoolMode",
		},
		resources: {
			allOf: [
				{
					$ref: "#/components/schemas/PoolerTemplateSpecContainersResources",
				},
			],
			nullable: true,
		},
	},
} as const;

export const PgConfigSchema = {
	type: "object",
	required: ["name", "value"],
	properties: {
		name: {
			type: "string",
		},
		value: {
			type: "string",
		},
	},
} as const;

export const PolicyDataSchema = {
	type: "object",
	required: ["policies"],
	properties: {
		policies: {
			type: "array",
			items: {
				$ref: "#/components/schemas/PolicyInput",
			},
		},
	},
} as const;

export const PolicyInputSchema = {
	type: "object",
	title: "Policy",
	required: ["action", "role", "allowed"],
	properties: {
		action: {
			type: "string",
			description: `A valid Action ID. Available Action IDs include 'CreateInstance' and 'ManagePermissions'.
Find all available Actions on the Actions API.`,
			example: "CreateInstance",
		},
		allowed: {
			type: "boolean",
			description: "Whether the Action is allowed or not for the Role",
			example: true,
		},
		role: {
			type: "string",
			description:
				"A valid Role ID. Available Role IDs include 'admin' and 'basic_member'.",
			example: "admin",
		},
	},
} as const;

export const PoolerPgbouncerPoolModeSchema = {
	type: "string",
	description: "The PgBouncer configuration",
	enum: ["session", "transaction"],
} as const;

export const PoolerTemplateSpecContainersResourcesSchema = {
	type: "object",
	description:
		"Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
	properties: {
		claims: {
			type: "array",
			items: {
				$ref: "#/components/schemas/PoolerTemplateSpecContainersResourcesClaims",
			},
			description: `Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
This field is immutable. It can only be set for containers.`,
			nullable: true,
		},
		limits: {
			type: "object",
			description:
				"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
			additionalProperties: {
				$ref: "#/components/schemas/IntOrString",
			},
			nullable: true,
		},
		requests: {
			type: "object",
			description:
				"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
			additionalProperties: {
				$ref: "#/components/schemas/IntOrString",
			},
			nullable: true,
		},
	},
} as const;

export const PoolerTemplateSpecContainersResourcesClaimsSchema = {
	type: "object",
	description: "ResourceClaim references one entry in PodSpec.ResourceClaims.",
	required: ["name"],
	properties: {
		name: {
			type: "string",
			description:
				"Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.",
		},
	},
} as const;

export const ProbeSchema = {
	type: "object",
	required: ["path", "port", "initialDelaySeconds"],
	properties: {
		initialDelaySeconds: {
			type: "integer",
			format: "int32",
			minimum: 0,
		},
		path: {
			type: "string",
		},
		port: {
			type: "integer",
			format: "int32",
		},
	},
} as const;

export const ProbesSchema = {
	type: "object",
	description: `Probes are used to determine the health of a container.
You define this in the same manner as you would for all Kubernetes containers.
See the [Kubernetes docs](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/).`,
	required: ["readiness", "liveness"],
	properties: {
		liveness: {
			$ref: "#/components/schemas/Probe",
		},
		readiness: {
			$ref: "#/components/schemas/Probe",
		},
	},
} as const;

export const ReplacePathRegexConfigSchema = {
	type: "object",
	required: ["name", "config"],
	properties: {
		config: {
			$ref: "#/components/schemas/ReplacePathRegexConfigType",
		},
		name: {
			type: "string",
		},
	},
} as const;

export const ReplacePathRegexConfigTypeSchema = {
	type: "object",
	required: ["regex", "replacement"],
	properties: {
		regex: {
			type: "string",
		},
		replacement: {
			type: "string",
		},
	},
} as const;

export const ReplicasSchema = {
	type: "integer",
	format: "int32",
} as const;

export const ResourceSchema = {
	type: "object",
	required: ["cpu", "memory"],
	properties: {
		cpu: {
			type: "string",
		},
		memory: {
			type: "string",
		},
	},
} as const;

export const ResourceRequirementsSchema = {
	type: "object",
	properties: {
		limits: {
			allOf: [
				{
					$ref: "#/components/schemas/Resource",
				},
			],
			nullable: true,
		},
		requests: {
			allOf: [
				{
					$ref: "#/components/schemas/Resource",
				},
			],
			nullable: true,
		},
	},
} as const;

export const RestoreSchema = {
	type: "object",
	required: ["instance_id"],
	properties: {
		instance_id: {
			type: "string",
		},
		recovery_target_time: {
			type: "string",
			format: "date-time",
			nullable: true,
		},
	},
} as const;

export const RestoreInstanceSchema = {
	type: "object",
	required: ["instance_name", "restore"],
	properties: {
		app_services: {
			type: "array",
			items: {
				$ref: "#/components/schemas/AppType",
			},
			nullable: true,
		},
		autoscaling: {
			allOf: [
				{
					$ref: "#/components/schemas/PatchAutoscaling",
				},
			],
			nullable: true,
		},
		connection_pooler: {
			allOf: [
				{
					$ref: "#/components/schemas/ConnectionPooler",
				},
			],
			nullable: true,
		},
		cpu: {
			allOf: [
				{
					$ref: "#/components/schemas/Cpu",
				},
			],
			nullable: true,
		},
		environment: {
			allOf: [
				{
					$ref: "#/components/schemas/Environment",
				},
			],
			nullable: true,
		},
		extra_domains_rw: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		instance_name: {
			type: "string",
		},
		memory: {
			allOf: [
				{
					$ref: "#/components/schemas/Memory",
				},
			],
			nullable: true,
		},
		restore: {
			$ref: "#/components/schemas/Restore",
		},
		storage: {
			allOf: [
				{
					$ref: "#/components/schemas/Storage",
				},
			],
			nullable: true,
		},
	},
} as const;

export const RoleSchema = {
	type: "object",
	required: ["id", "name"],
	properties: {
		id: {
			type: "string",
			description:
				"A valid Role ID. Available Role IDs include 'admin' and 'basic_member'.",
		},
		name: {
			type: "string",
			description: "The name of the Role.",
		},
	},
} as const;

export const RoutingSchema = {
	type: "object",
	description: `Routing is used if there is a routing port, then a service is created using
that Port when ingress_path is present, an ingress is created. Otherwise, no
ingress is created`,
	required: ["port"],
	properties: {
		entryPoints: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		ingressPath: {
			type: "string",
			nullable: true,
		},
		ingressType: {
			allOf: [
				{
					$ref: "#/components/schemas/IngressType",
				},
			],
			nullable: true,
		},
		middlewares: {
			type: "array",
			items: {
				type: "string",
			},
			description:
				"provide name of the middleware resources to apply to this route",
			nullable: true,
		},
		port: {
			type: "integer",
			format: "int32",
			minimum: 0,
		},
	},
} as const;

export const SearchParamsSchema = {
	type: "object",
	required: ["query"],
	properties: {
		limit: {
			type: "integer",
			format: "int32",
			description: "The number of results to return. Default is 10, max is 20.",
			nullable: true,
		},
		query: {
			type: "string",
			description:
				'The search query. For example, "how to create a Tembo instance"',
		},
	},
} as const;

export const SearchResponseSchema = {
	type: "object",
	required: ["file_path", "similarity_score"],
	properties: {
		file_path: {
			type: "string",
			description:
				"The file path (in Tembo website repo) to the Tembo document",
		},
		front_matter: {
			nullable: true,
		},
		similarity_score: {
			type: "number",
			format: "double",
		},
	},
} as const;

export const StackTypeSchema = {
	type: "string",
	enum: [
		"Analytics",
		"DataWarehouse",
		"Geospatial",
		"MachineLearning",
		"MessageQueue",
		"MongoAlternative",
		"OLAP",
		"OLTP",
		"ParadeDB",
		"RAG",
		"Standard",
		"Timeseries",
		"VectorDB",
	],
} as const;

export const StateSchema = {
	type: "string",
	enum: [
		"Submitted",
		"Up",
		"Configuring",
		"Error",
		"Restarting",
		"Starting",
		"Stopping",
		"Stopped",
		"Deleting",
		"Deleted",
	],
} as const;

export const StorageSchema = {
	type: "string",
	enum: [
		"10Gi",
		"50Gi",
		"100Gi",
		"200Gi",
		"300Gi",
		"400Gi",
		"500Gi",
		"1Ti",
		"1.5Ti",
		"2Ti",
	],
} as const;

export const StorageConfigSchema = {
	type: "object",
	properties: {
		volumeMounts: {
			type: "array",
			items: {
				$ref: "#/components/schemas/VolumeMount",
			},
			nullable: true,
		},
	},
} as const;

export const StripPrefixConfigSchema = {
	type: "object",
	required: ["name", "config"],
	properties: {
		config: {
			type: "array",
			items: {
				type: "string",
			},
		},
		name: {
			type: "string",
		},
	},
} as const;

export const TrunkInstallSchema = {
	type: "object",
	description: `TrunkInstall allows installation of extensions from the [pgtrunk](https://pgt.dev)
registry.  This list should be a list of extension names and versions that you wish to
install at runtime using the pgtrunk API.

This example will install the pg_stat_statements extension at version 1.10.0.

\`\`\`yaml
apiVersion: coredb.io/v1alpha1
kind: CoreDB
metadata:
name: test-db
spec:
trunk_installs:
- name: pg_stat_statements
version: 1.10.0
\`\`\``,
	required: ["name"],
	properties: {
		name: {
			type: "string",
			description: `The name of the extension to install. This must be the name of the extension as it
appears in the [pgtrunk](https://pgt.dev) registry.`,
		},
		version: {
			type: "string",
			description: `The version of the extension to install. If not specified, the latest version will
be used. (Optional)`,
			nullable: true,
		},
	},
} as const;

export const TrunkInstallStatusSchema = {
	type: "object",
	required: ["name", "error"],
	properties: {
		error: {
			type: "boolean",
		},
		error_message: {
			type: "string",
			nullable: true,
		},
		installed_to_pods: {
			type: "array",
			items: {
				type: "string",
			},
			nullable: true,
		},
		loading: {
			type: "boolean",
		},
		name: {
			type: "string",
		},
		version: {
			type: "string",
			nullable: true,
		},
	},
} as const;

export const VolumeMountSchema = {
	type: "object",
	required: ["mount_path", "name"],
	properties: {
		mount_path: {
			type: "string",
		},
		mount_propagation: {
			type: "string",
			nullable: true,
		},
		name: {
			type: "string",
		},
		read_only: {
			type: "boolean",
			nullable: true,
		},
		sub_path: {
			type: "string",
			nullable: true,
		},
		sub_path_expr: {
			type: "string",
			nullable: true,
		},
	},
} as const;

export const dedicated_networkingSchema = {
	type: "object",
	description: "Configuration for dedicated networking.",
	properties: {
		enabled: {
			type: "boolean",
			description:
				"Enables or disables dedicated networking. Default is false.",
			nullable: true,
		},
		includeStandby: {
			type: "boolean",
			description:
				"If true, includes the standby instance in the dedicated networking setup. Default is false.",
			nullable: true,
		},
	},
} as const;
